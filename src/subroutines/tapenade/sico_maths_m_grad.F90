!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) -  7 Sep 2021 16:00
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  Module :  s i c o _ s l e _ s o l v e r s
!
!> @file
!!
!! Solvers for systems of linear equations used by SICOPOLIS.
!!
!! @section Copyright
!!
!! Copyright 2009-2021 Ralf Greve, Tatsuru Sato
!!
!! @section License
!!
!! This file is part of SICOPOLIS.
!!
!! SICOPOLIS is free software: you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation, either version 3 of the License, or
!! (at your option) any later version.
!!
!! SICOPOLIS is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with SICOPOLIS.  If not, see <http://www.gnu.org/licenses/>.
!<
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!-------------------------------------------------------------------------------
!> Solvers for systems of linear equations used by SICOPOLIS.
!<------------------------------------------------------------------------------
MODULE SICO_MATHS_M_DIFF
  USE SICO_TYPES_M
  IMPLICIT NONE
  PUBLIC
  INTERFACE SOR_SPRS
      MODULE PROCEDURE SOR_SPRS_STUB
  END INTERFACE

  INTERFACE SOR_SPRS_B
      MODULE PROCEDURE SOR_SPRS_STUB_B
  END INTERFACE

  INTERFACE TRI_SLE
      MODULE PROCEDURE TRI_SLE_STUB
  END INTERFACE

  INTERFACE TRI_SLE_B
      MODULE PROCEDURE TRI_SLE_STUB_B
  END INTERFACE

  !INTERFACE BILININT
  !    MODULE PROCEDURE BILININT_STUB
  !END INTERFACE

  INTERFACE MY_ERFC
      MODULE PROCEDURE MY_ERFC_STUB
  END INTERFACE

  INTERFACE MY_ERFC_B
      MODULE PROCEDURE MY_ERFC_STUB_B
  END INTERFACE

#if  defined(BUILD_LIS) && (CALCTHK==3 || CALCTHK==6 || MARGIN==3 || DYNAMICS==2)
  INTERFACE SICO_LIS_SOLVER
      MODULE PROCEDURE SICO_LIS_SOLVER_STUB
  END INTERFACE

  INTERFACE SICO_LIS_SOLVER_B
      MODULE PROCEDURE SICO_LIS_SOLVER_STUB_B
  END INTERFACE
#endif

CONTAINS

subroutine transpose_csr(a_value, a_index, a_diag_index, a_ptr, &
                    nnz, nmax, &
                    b_value, b_index, b_diag_index, b_ptr)

implicit none

integer(i4b),                     intent(in)  :: nnz, nmax
integer(i4b), dimension(nmax+1),  intent(in)  :: a_ptr
integer(i4b), dimension(nnz),     intent(in)  :: a_index
integer(i4b), dimension(nmax),    intent(in)  :: a_diag_index
real(dp),     dimension(nnz),     intent(in)  :: a_value
integer(i4b), dimension(nmax+1),  intent(out) :: b_ptr
integer(i4b), dimension(nnz),     intent(out) :: b_index
integer(i4b), dimension(nmax),    intent(out) :: b_diag_index
real(dp),     dimension(nnz),     intent(out) :: b_value

integer(i4b) :: nr, k
integer(i4b), dimension(nmax)                 :: b_ptr_plus

   b_ptr = 0
   do nr=1, nmax
      do k=a_ptr(nr), a_ptr(nr+1)-1
         b_ptr(a_index(k)+1) = b_ptr(a_index(k)+1) + 1
      end do
   end do
   b_ptr(1) = 1
   do nr=1, nmax
     b_ptr(nr+1) = b_ptr(nr) + b_ptr(nr+1)
   end do
   b_ptr_plus = 0
   do nr=1, nmax
      do k=a_ptr(nr), a_ptr(nr+1)-1
         b_index(b_ptr(a_index(k)) + b_ptr_plus(a_index(k))) = nr
         if(a_index(k).eq.nr)then
           b_diag_index(nr) = b_ptr(a_index(k)) + b_ptr_plus(a_index(k))
         end if
         b_value(b_ptr(a_index(k)) + b_ptr_plus(a_index(k))) = a_value(k)
         b_ptr_plus(a_index(k)) = b_ptr_plus(a_index(k)) + 1
      end do
   end do
end subroutine transpose_csr

!  Differentiation of sor_sprs_stub in reverse (adjoint) mode:
!   gradient     of useful results: lgs_x_value
!   with respect to varying inputs: lgs_b_value lgs_x_value lgs_a_value
!-------------------------------------------------------------------------------
!> SOR solver for a system of linear equations lgs_a*lgs_x=lgs_b
!! [matrix storage: compressed sparse row CSR,
!! represented by arrays lgs_a_value(values), lgs_a_index (indices)
!! and lgs_a_ptr (pointers)].
!<------------------------------------------------------------------------------
  SUBROUTINE SOR_SPRS_STUB_B(lgs_a_value, lgs_a_valueb, lgs_a_index, &
&   lgs_a_diag_index, lgs_a_ptr, lgs_b_value, lgs_b_valueb, nnz, nmax, &
&   omega, eps_sor, lgs_x_value, lgs_x_valueb, ierr)

implicit none

integer(i4b),                     intent(in) :: nnz, nmax
real(dp),                         intent(in) :: omega, eps_sor
integer(i4b), dimension(nmax+1),  intent(in) :: lgs_a_ptr
integer(i4b), dimension(nnz),     intent(in) :: lgs_a_index
integer(i4b), dimension(nmax),    intent(in) :: lgs_a_diag_index
real(dp),     dimension(nnz),     intent(in) :: lgs_a_value
real(dp),     dimension(nmax),    intent(in) :: lgs_b_value

integer(i4b),                    intent(out) :: ierr
real(dp),     dimension(nmax), intent(inout) :: lgs_x_value

real(dp),     dimension(nnz),  intent(inout) :: lgs_a_valueb
real(dp),     dimension(nmax), intent(inout) :: lgs_b_valueb
real(dp),     dimension(nmax), intent(inout) :: lgs_x_valueb

integer(i4b), dimension(nmax+1)              :: lgs_aT_ptr
integer(i4b), dimension(nnz)                 :: lgs_aT_index
integer(i4b), dimension(nmax)                :: lgs_aT_diag_index
real(dp),     dimension(nnz)                 :: lgs_aT_value
real(dp),     dimension(nmax)                :: incrbb
integer(i4b) :: iter
integer(i4b) :: nr, k
real(dp), allocatable, dimension(:) :: lgs_x_value_prev
real(dp)     :: b_nr
logical      :: flag_convergence
logical      :: inif, infor

  incrbb = 0.0
  call transpose_csr(lgs_a_value, lgs_a_index, lgs_a_diag_index, lgs_a_ptr, &
                    nnz, nmax, &
                    lgs_aT_value, lgs_aT_index, lgs_aT_diag_index, lgs_aT_ptr)

  call sor_sprs(lgs_aT_value, lgs_aT_index, lgs_aT_diag_index, lgs_aT_ptr, &
                    lgs_x_valueb, &
                    nnz, nmax, omega, eps_sor, incrbb, ierr)

  DO nr=1,nmax
    lgs_b_valueb(nr) = lgs_b_valueb(nr) + incrbb(nr)
  ENDDO

  call sor_sprs(lgs_a_value, lgs_a_index, lgs_a_diag_index, lgs_a_ptr, &
                    lgs_b_value, &
                    nnz, nmax, omega, eps_sor, lgs_x_value, ierr)
  do nr=1, nmax
    inif = .false. 
    infor = .false. 
    if(nr .eq. lgs_a_diag_index(nr)) then
      inif = .true.
      lgs_a_valueb(lgs_a_diag_index(nr)) = lgs_a_valueb(lgs_a_diag_index(nr)) -&
             lgs_x_value(lgs_a_index(nr)) * incrbb(nr)
    end if
    do k=lgs_a_ptr(nr), lgs_a_ptr(nr+1)-1
      infor = .true.
      lgs_a_valueb(k) = lgs_a_valueb(k) - lgs_x_value(lgs_a_index(k)) *incrbb(nr)
    end do
  end do
  lgs_x_valueb = 0.0
  END SUBROUTINE SOR_SPRS_STUB_B

!-------------------------------------------------------------------------------
!> SOR solver for a system of linear equations lgs_a*lgs_x=lgs_b
!! [matrix storage: compressed sparse row CSR,
!! represented by arrays lgs_a_value(values), lgs_a_index (indices)
!! and lgs_a_ptr (pointers)].
!<------------------------------------------------------------------------------
  SUBROUTINE SOR_SPRS_STUB(lgs_a_value, lgs_a_index, lgs_a_diag_index, &
&   lgs_a_ptr, lgs_b_value, nnz, nmax, omega, eps_sor, &
&   lgs_x_value, ierr)

  implicit none

  integer(i4b),                     intent(in) :: nnz, nmax
  real(dp),                         intent(in) :: omega, eps_sor
  integer(i4b), dimension(nmax+1),  intent(in) :: lgs_a_ptr
  integer(i4b), dimension(nnz),     intent(in) :: lgs_a_index
  integer(i4b), dimension(nmax),    intent(in) :: lgs_a_diag_index
  real(dp),     dimension(nnz),     intent(in) :: lgs_a_value
  real(dp),     dimension(nmax),    intent(in) :: lgs_b_value

  integer(i4b),                    intent(out) :: ierr
  real(dp),     dimension(nmax), intent(inout) :: lgs_x_value

  integer(i4b) :: iter
  integer(i4b) :: iter_max
  integer(i4b) :: nr, k
  real(dp), allocatable, dimension(:) :: lgs_x_value_prev
  real(dp)     :: b_nr
  logical      :: flag_convergence

#if (ITER_MAX_SOR > 0)
  iter_max = ITER_MAX_SOR
#else
  iter_max = 1000   ! default value
#endif

  allocate(lgs_x_value_prev(nmax))

  iter_loop : do iter=1, iter_max

     lgs_x_value_prev = lgs_x_value

     do nr=1, nmax

        b_nr = 0.0_dp 

        do k=lgs_a_ptr(nr), lgs_a_ptr(nr+1)-1
           b_nr = b_nr + lgs_a_value(k)*lgs_x_value(lgs_a_index(k))
        end do

        lgs_x_value(nr) = lgs_x_value(nr) &
                          -omega*(b_nr-lgs_b_value(nr)) &
                                /lgs_a_value(lgs_a_diag_index(nr))

     end do

     flag_convergence = .true.
     do nr=1, nmax
        if (abs(lgs_x_value(nr)-lgs_x_value_prev(nr)) > eps_sor) then
           flag_convergence = .false.
           exit
        end if
     end do

     if (flag_convergence) then
        write(6,'(10x,a,i0)') 'sor_sprs: iter = ', iter
        ierr = 0   ! convergence criterion fulfilled
        deallocate(lgs_x_value_prev)
        return
     end if

  end do iter_loop

  write(6,'(10x,a,i0)') 'sor_sprs: iter = ', iter
  ierr = -1   ! convergence criterion not fulfilled
  deallocate(lgs_x_value_prev)

  END SUBROUTINE SOR_SPRS_STUB

!  Differentiation of tri_sle_stub in reverse (adjoint) mode:
!   gradient     of useful results: x
!   with respect to varying inputs: x a0 a1 a2 b
!-------------------------------------------------------------------------------
!> Solution of a system of linear equations Ax=b with tridiagonal matrix A.
!! @param[in]  a0       a0(j) is element A_(j,j-1) of Matrix A
!! @param[in]  a1       a1(j) is element A_(j,j)   of Matrix A
!! @param[in]  a2       a2(j) is element A_(j,j+1) of Matrix A
!! @param[in]  b        inhomogeneity vector
!! @param[in]  nrows    size of matrix A (indices run from 0 (!!!) to nrows)
!! @param[out] x        Solution vector.
!<------------------------------------------------------------------------------
  SUBROUTINE TRI_SLE_STUB_B(a0, a0b, a1, a1b, a2, a2b, x, xb, b, bb, &
&   nrows)

    IMPLICIT NONE
    INTEGER(i4b), INTENT(IN) :: nrows
    REAL(dp), DIMENSION(0:nrows), INTENT(IN) :: a0, a1, a2, b
    REAL(dp), DIMENSION(0:nrows) :: a0b, a1b, a2b, bb
    REAL(dp), DIMENSION(0:nrows) :: x, x_copy
    REAL(dp), DIMENSION(0:nrows) :: xb
    INTEGER(i4b) :: n


    real(dp), dimension(0:nrows) :: a0T, a1T, a2T
    real(dp), dimension(0:nrows) :: incrbb
    integer(i4b) :: i

        a0T(0) = 0.0   
        a0T(1:nrows) = a2(0:nrows-1)
        a1T(0:nrows) = a1(0:nrows)
        a2T(0:nrows-1) = a0(1:nrows)
        a2T(nrows) = 0.0
        call tri_sle(a0T, a1T, a2T, incrbb, xb, nrows)
        DO i=0,nrows
          bb(i) = incrbb(i)
        ENDDO
        ! The results go wrong when x is calculated here, so calculate x_copy.
        call tri_sle(a0, a1, a2, x_copy, b, nrows)
        DO i=0,nrows
          a0b(i) = - x_copy(i-1)*incrbb(i)
        ENDDO
        DO i=0,nrows
          a1b(i) = - x_copy(i)*incrbb(i)
        ENDDO
        DO i=0,nrows
          a2b(i) = - x_copy(i+1)*incrbb(i)
        ENDDO
        xb = 0.0



  END SUBROUTINE TRI_SLE_STUB_B

!-------------------------------------------------------------------------------
!> Solution of a system of linear equations Ax=b with tridiagonal matrix A.
!! @param[in]  a0       a0(j) is element A_(j,j-1) of Matrix A
!! @param[in]  a1       a1(j) is element A_(j,j)   of Matrix A
!! @param[in]  a2       a2(j) is element A_(j,j+1) of Matrix A
!! @param[in]  b        inhomogeneity vector
!! @param[in]  nrows    size of matrix A (indices run from 0 (!!!) to nrows)
!! @param[out] x        Solution vector.
!<------------------------------------------------------------------------------
  SUBROUTINE TRI_SLE_STUB(a0, a1, a2, x, b, nrows)

  implicit none

  integer(i4b),                 intent(in) :: nrows
  real(dp), dimension(0:nrows), intent(in) :: a0, a1, a2, b

  real(dp), dimension(0:nrows), intent(out) :: x

  integer(i4b) :: n
  real(dp), dimension(0:nrows) :: a0_aux, a1_aux, a2_aux, b_aux, x_aux

!--------  Define local variables --------

  a0_aux = a0
  a1_aux = a1
  a2_aux = a2
  b_aux  = b
  x_aux  = 0.0_dp   ! initialization

!--------  Generate an upper triangular matrix --------

  do n=1, nrows
     a1_aux(n) = a1_aux(n) - a0_aux(n)/a1_aux(n-1)*a2_aux(n-1)
  end do

  do n=1, nrows
     b_aux(n) = b_aux(n) - a0_aux(n)/a1_aux(n-1)*b_aux(n-1)
     ! a0_aux(n) = 0.0_dp , not needed in the following, therefore not set
  end do

!-------- Iterative solution of the new system --------

  x_aux(0) = b_aux(nrows)/a1_aux(nrows)

  do n=1, nrows
     x_aux(n) = b_aux(nrows-n)/a1_aux(nrows-n) &
                -a2_aux(nrows-n)/a1_aux(nrows-n)*x_aux(n-1)
  end do

  do n=0, nrows
     x(n) = x_aux(nrows-n)
  end do

  !  WARNING: Subroutine does not check for elements of the main
  !           diagonal becoming zero. In this case it crashes even
  !           though the system may be solvable. Otherwise ok.

  END SUBROUTINE TRI_SLE_STUB

!-------------------------------------------------------------------------------
!> Bilinear interpolation.
!<------------------------------------------------------------------------------
  function bilinint(x1, x2, y1, y2, z11, z12, z21, z22, x, y)

  implicit none

  real(dp), intent(in) :: x1, x2, y1, y2, z11, z12, z21, z22, x, y

  real(dp) :: t, u
  real(dp) :: bilinint

  real(dp), parameter :: I = 1.0_dp

  t = (x-x1)/(x2-x1)
  u = (y-y1)/(y2-y1)

  bilinint = (I-t)*(I-u)*z11 + (I-t)*u*z12 + t*(I-u)*z21 + t*u*z22

  end function bilinint
  

!  Differentiation of my_erfc_stub in reverse (adjoint) mode:
!   gradient     of useful results: retval
!   with respect to varying inputs: x
!-------------------------------------------------------------------------------
!> Computation of the complementary error function erfc(x) = 1-erf(x)
!! with a fractional error everywhere less than 1.2 x 10^(-7)
!! (formula by Press et al., 'Numerical Recipes in Fortran 77').
!<------------------------------------------------------------------------------
  SUBROUTINE MY_ERFC_STUB_B(x, xb, retval, retvalb)
    IMPLICIT NONE
    REAL(dp), INTENT(IN) :: x
    REAL(dp) :: xb
    REAL(dp) :: retval
    REAL(dp) :: retvalb
    REAL(dp) :: t, z
    REAL(dp) :: tb, zb
    INTRINSIC ABS
    INTRINSIC EXP
    REAL(dp) :: temp
    REAL(dp) :: temp0
    REAL(dp) :: temp1
    REAL(dp) :: temp2
    REAL(dp) :: temp3
    REAL(dp) :: temp4
    REAL(dp) :: tempb
    REAL(dp) :: tempb0
    REAL(dp) :: tempb1
    REAL(dp) :: tempb2
    INTEGER*4 :: branch
    IF (x .GE. 0.) THEN
      z = x
      CALL PUSHCONTROL1B(0)
    ELSE
      z = -x
      CALL PUSHCONTROL1B(1)
    END IF
    t = 1.0_dp/(1.0_dp+0.5_dp*z)
    IF (x .LT. 0.0_dp) retvalb = -retvalb
    temp = t*(0.17087277_dp*t-0.82215223_dp) + 1.48851587_dp
    temp0 = t*temp - 1.13520398_dp
    temp1 = t*(t*temp0+0.27886807_dp) - 0.18628806_dp
    temp2 = t*(t*temp1+0.09678418_dp) + 0.37409196_dp
    temp3 = t*temp2 + 1.00002368_dp
    temp4 = t*temp3 - z*z - 1.26551223_dp
    tempb = EXP(temp4)*t*retvalb
    tempb0 = t**2*tempb
    tempb1 = t**2*tempb0
    tempb2 = t**2*tempb1
    tb = EXP(temp4)*retvalb + (temp3+temp2*t)*tempb + (t*temp1+temp1*t+&
&     0.09678418_dp)*tempb0 + (t*temp0+temp0*t+0.27886807_dp)*tempb1 + (&
&     temp+(0.17087277_dp*t-0.82215223_dp)*t+0.17087277_dp*t**2)*tempb2
    zb = -(2*z*tempb) - 0.5_dp*tb/(0.5_dp*z+1.0_dp)**2
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      xb = zb
    ELSE
      xb = -zb
    END IF
  END SUBROUTINE MY_ERFC_STUB_B

!-------------------------------------------------------------------------------
!> Computation of the complementary error function erfc(x) = 1-erf(x)
!! with a fractional error everywhere less than 1.2 x 10^(-7)
!! (formula by Press et al., 'Numerical Recipes in Fortran 77').
!<------------------------------------------------------------------------------
  SUBROUTINE MY_ERFC_STUB(x, retval)
    IMPLICIT NONE
    REAL(dp), INTENT(IN) :: x
    REAL(dp), INTENT(OUT) :: retval
    REAL(dp) :: t, z
    INTRINSIC ABS
    INTRINSIC EXP
    IF (x .GE. 0.) THEN
      z = x
    ELSE
      z = -x
    END IF
    t = 1.0_dp/(1.0_dp+0.5_dp*z)
    retval = t*EXP(-(z*z)-1.26551223_dp+t*(1.00002368_dp+t*(&
&     0.37409196_dp+t*(0.09678418_dp+t*(-0.18628806_dp+t*(0.27886807_dp+&
&     t*(-1.13520398_dp+t*(1.48851587_dp+t*(-0.82215223_dp+t*&
&     0.17087277_dp)))))))))
    IF (x .LT. 0.0_dp) retval = 2.0_dp - retval
  END SUBROUTINE MY_ERFC_STUB

!-------------------------------------------------------------------------------
  SUBROUTINE MY_ERFC(x, retval)
    IMPLICIT NONE
    REAL(dp), INTENT(IN) :: x
    REAL(dp), INTENT(OUT) :: retval
    REAL(dp) :: t, z
    INTRINSIC ABS
    INTRINSIC EXP
    IF (x .GE. 0.) THEN
      z = x
    ELSE
      z = -x
    END IF
    t = 1.0_dp/(1.0_dp+0.5_dp*z)
    retval = t*EXP(-(z*z)-1.26551223_dp+t*(1.00002368_dp+t*(&
&     0.37409196_dp+t*(0.09678418_dp+t*(-0.18628806_dp+t*(0.27886807_dp+&
&     t*(-1.13520398_dp+t*(1.48851587_dp+t*(-0.82215223_dp+t*&
&     0.17087277_dp)))))))))
    IF (x .LT. 0.0_dp) retval = 2.0_dp - retval
  END SUBROUTINE MY_ERFC

#if  defined(BUILD_LIS) && (CALCTHK==3 || CALCTHK==6 || MARGIN==3 || DYNAMICS==2)
subroutine transpose_csr_no_diagonal(a_value, a_index, a_ptr, &
                    nnz, nmax, &
                    b_value, b_index, b_ptr)

implicit none

integer(i4b),                     intent(in)  :: nnz, nmax
integer(i4b), dimension(nmax+1),  intent(in)  :: a_ptr
integer(i4b), dimension(nnz),     intent(in)  :: a_index
real(dp),     dimension(nnz),     intent(in)  :: a_value
integer(i4b), dimension(nmax+1),  intent(out) :: b_ptr
integer(i4b), dimension(nnz),     intent(out) :: b_index
real(dp),     dimension(nnz),     intent(out) :: b_value

integer(i4b) :: nr, k
integer(i4b), dimension(nmax)                 :: b_ptr_plus

   b_ptr = 0
   do nr=1, nmax
      do k=a_ptr(nr), a_ptr(nr+1)-1
         b_ptr(a_index(k)+1) = b_ptr(a_index(k)+1) + 1
      end do
   end do
   b_ptr(1) = 1
   do nr=1, nmax
     b_ptr(nr+1) = b_ptr(nr) + b_ptr(nr+1)
   end do
   b_ptr_plus = 0
   do nr=1, nmax
      do k=a_ptr(nr), a_ptr(nr+1)-1
         b_index(b_ptr(a_index(k)) + b_ptr_plus(a_index(k))) = nr
         b_value(b_ptr(a_index(k)) + b_ptr_plus(a_index(k))) = a_value(k)
         b_ptr_plus(a_index(k)) = b_ptr_plus(a_index(k)) + 1
      end do
   end do
end subroutine transpose_csr_no_diagonal

#include "lisf.h"
  SUBROUTINE SICO_LIS_SOLVER_STUB(nmax, nnz, lgs_a_ptr, lgs_a_index, &
&   lgs_a_value, lgs_b_value, lgs_x_value)
implicit none

integer(i4b)                                 :: ierr
integer(i4b)                                 :: iter
integer(i4b)                                 :: nc, nr
integer(i4b),                     intent(in) :: nmax
integer(i4b),                     intent(in) :: nnz
integer(i4b), dimension(nmax+1),  intent(in) :: lgs_a_ptr
integer(i4b), dimension(nnz),  intent(in)    :: lgs_a_index

LIS_MATRIX                                   :: lgs_a
LIS_VECTOR                                   :: lgs_b
LIS_VECTOR                                   :: lgs_x
LIS_SOLVER                                   :: solver

real(dp),     dimension(nnz),  intent(in)    :: lgs_a_value
real(dp),     dimension(nmax),    intent(in) :: lgs_b_value
real(dp),     dimension(nmax), intent(inout) :: lgs_x_value

character(len=256)                           :: ch_solver_set_option

!  ------ Settings for Lis
call lis_init_f(ierr)
call lis_matrix_create(LIS_COMM_WORLD, lgs_a, ierr)
call lis_vector_create(LIS_COMM_WORLD, lgs_b, ierr)
call lis_vector_create(LIS_COMM_WORLD, lgs_x, ierr)

call lis_matrix_set_size(lgs_a, 0, nmax, ierr)
call lis_vector_set_size(lgs_b, 0, nmax, ierr)
call lis_vector_set_size(lgs_x, 0, nmax, ierr)

do nr=1, nmax

   do nc=lgs_a_ptr(nr), lgs_a_ptr(nr+1)-1
      call lis_matrix_set_value(LIS_INS_VALUE, nr, lgs_a_index(nc), &
                                               lgs_a_value(nc), lgs_a, ierr)
   end do

   call lis_vector_set_value(LIS_INS_VALUE, nr, lgs_b_value(nr), lgs_b, ierr)
   call lis_vector_set_value(LIS_INS_VALUE, nr, lgs_x_value(nr), lgs_x, ierr)

end do

call lis_matrix_set_type(lgs_a, LIS_MATRIX_CSR, ierr)
call lis_matrix_assemble(lgs_a, ierr)

!  ------ Solution with Lis

call lis_solver_create(solver, ierr)

ch_solver_set_option = trim(LIS_OPTS)

call lis_solver_set_option(trim(ch_solver_set_option), solver, ierr)
call CHKERR(ierr)

call lis_solve(lgs_a, lgs_b, lgs_x, solver, ierr)
call CHKERR(ierr)

call lis_solver_get_iter(solver, iter, ierr)
write(6,'(10x,a,i0)') 'calc_thk_sia_impl: iter = ', iter

lgs_x_value = 0.0_dp
call lis_vector_gather(lgs_x, lgs_x_value, ierr)
call lis_matrix_destroy(lgs_a, ierr)
call lis_vector_destroy(lgs_b, ierr)
call lis_vector_destroy(lgs_x, ierr)
call lis_solver_destroy(solver, ierr)
call lis_finalize_f(ierr)
  END SUBROUTINE SICO_LIS_SOLVER_STUB

!  Differentiation of sico_lis_solver_stub in reverse (adjoint) mode:
!   gradient     of useful results: lgs_x_value
!   with respect to varying inputs: lgs_b_value lgs_x_value lgs_a_value
  SUBROUTINE SICO_LIS_SOLVER_STUB_B(nmax, nnz, lgs_a_ptr, lgs_a_index, &
&   lgs_a_value, lgs_a_valueb, lgs_b_value, lgs_b_valueb, lgs_x_value, &
&   lgs_x_valueb)
implicit none

integer(i4b)                                 :: nc, nr
integer(i4b),                     intent(in) :: nmax
integer(i4b),                     intent(in) :: nnz
integer(i4b), dimension(nmax+1),  intent(in) :: lgs_a_ptr
integer(i4b), dimension(nnz),  intent(in) :: lgs_a_index

real(dp),     dimension(nnz),  intent(in) :: lgs_a_value
real(dp),     dimension(nmax),    intent(in) :: lgs_b_value
real(dp),     dimension(nmax), intent(inout) :: lgs_x_value

real(dp),     dimension(nnz),  intent(inout) :: lgs_a_valueb
real(dp),     dimension(nmax), intent(inout) :: lgs_b_valueb
real(dp),     dimension(nmax), intent(inout) :: lgs_x_valueb

integer(i4b), dimension(nmax+1)              :: lgs_aT_ptr
integer(i4b), dimension(nnz)              :: lgs_aT_index
real(dp),     dimension(nnz)              :: lgs_aT_value
real(dp),     dimension(nmax)                :: incrbb

lgs_aT_value = 0.
lgs_aT_index = 0
lgs_aT_value = 0.
  call transpose_csr_no_diagonal(lgs_a_value, lgs_a_index, lgs_a_ptr, &
                    nnz, nmax, &
                    lgs_aT_value, lgs_aT_index, lgs_aT_ptr)

incrbb = 0.
  call sico_lis_solver(nmax, nnz, &
                           lgs_aT_ptr, lgs_aT_index, &
                           lgs_aT_value, lgs_x_valueb, incrbb)
  DO nr=1,nmax
    lgs_b_valueb(nr) = lgs_b_valueb(nr) + incrbb(nr)
  ENDDO

  call sico_lis_solver(nmax, nnz, &
                           lgs_a_ptr, lgs_a_index, &
                           lgs_a_value, lgs_b_value, lgs_x_value)

  do nr=1, nmax
    do nc=lgs_a_ptr(nr), lgs_a_ptr(nr+1)-1
      lgs_a_valueb(nc) = lgs_a_valueb(nc) - lgs_x_value(lgs_a_index(nc)) *incrbb(nr)
    end do
  end do
  lgs_x_valueb = 0.0
  END SUBROUTINE SICO_LIS_SOLVER_STUB_B
#endif

END MODULE SICO_MATHS_M_DIFF
!

