!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) -  7 Sep 2021 16:00
!
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!
!  Module :  s i c o _ s l e _ s o l v e r s
!
!> @file
!!
!! Solvers for systems of linear equations used by SICOPOLIS.
!!
!! @section Copyright
!!
!! Copyright 2009-2021 Ralf Greve, Tatsuru Sato
!!
!! @section License
!!
!! This file is part of SICOPOLIS.
!!
!! SICOPOLIS is free software: you can redistribute it and/or modify
!! it under the terms of the GNU General Public License as published by
!! the Free Software Foundation, either version 3 of the License, or
!! (at your option) any later version.
!!
!! SICOPOLIS is distributed in the hope that it will be useful,
!! but WITHOUT ANY WARRANTY; without even the implied warranty of
!! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!! GNU General Public License for more details.
!!
!! You should have received a copy of the GNU General Public License
!! along with SICOPOLIS.  If not, see <http://www.gnu.org/licenses/>.
!<
!+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!-------------------------------------------------------------------------------
!> Solvers for systems of linear equations used by SICOPOLIS.
!<------------------------------------------------------------------------------
MODULE SICO_MATHS_M_DIFF
  USE SICO_TYPES_M
  IMPLICIT NONE
  PUBLIC
  INTERFACE TRI_SLE
      MODULE PROCEDURE TRI_SLE_STUB
  END INTERFACE

  INTERFACE TRI_SLE_D
      MODULE PROCEDURE TRI_SLE_STUB_D
  END INTERFACE

  INTERFACE BILININT
      MODULE PROCEDURE BILININT_STUB
  END INTERFACE

  INTERFACE MY_ERFC
      MODULE PROCEDURE MY_ERFC_STUB
  END INTERFACE

  INTERFACE MY_ERFC_D
      MODULE PROCEDURE MY_ERFC_STUB_D
  END INTERFACE

  INTERFACE SOR_SPRS
      MODULE PROCEDURE SOR_SPRS_STUB
  END INTERFACE

  INTERFACE SOR_SPRS_D
      MODULE PROCEDURE SOR_SPRS_STUB_D
  END INTERFACE

#if  defined(BUILD_LIS) && (CALCTHK==3 || CALCTHK==6 || MARGIN==3 || DYNAMICS==2)
  INTERFACE SICO_LIS_SOLVER
      MODULE PROCEDURE SICO_LIS_SOLVER_STUB
  END INTERFACE

  INTERFACE SICO_LIS_SOLVER_D
      MODULE PROCEDURE SICO_LIS_SOLVER_STUB_D
  END INTERFACE
#endif

CONTAINS
!  Differentiation of sor_sprs_stub in forward (tangent) mode:
!   variations   of useful results: lgs_x_value
!   with respect to varying inputs: lgs_b_value lgs_x_value lgs_a_value
!-------------------------------------------------------------------------------
!> SOR solver for a system of linear equations lgs_a*lgs_x=lgs_b
!! [matrix storage: compressed sparse row CSR,
!! represented by arrays lgs_a_value(values), lgs_a_index (indices)
!! and lgs_a_ptr (pointers)].
!<------------------------------------------------------------------------------
  SUBROUTINE SOR_SPRS_STUB_D(lgs_a_value, lgs_a_valued, lgs_a_index, &
&   lgs_a_diag_index, lgs_a_ptr, lgs_b_value, lgs_b_valued, nnz, nmax, &
&   n_sprs, omega, eps_sor, lgs_x_value, lgs_x_valued, ierr)
    IMPLICIT NONE
    INTEGER(i4b), INTENT(IN) :: n_sprs
    INTEGER(i4b), INTENT(IN) :: nnz, nmax
    REAL(dp), INTENT(IN) :: omega, eps_sor
    INTEGER(i4b), DIMENSION(nmax+1), INTENT(IN) :: lgs_a_ptr
    INTEGER(i4b), DIMENSION(nnz), INTENT(IN) :: lgs_a_index
    INTEGER(i4b), DIMENSION(nmax), INTENT(IN) :: lgs_a_diag_index
    REAL(dp), DIMENSION(nnz), INTENT(IN) :: lgs_a_value
    REAL(dp), DIMENSION(nnz), INTENT(IN) :: lgs_a_valued
    REAL(dp), DIMENSION(nmax), INTENT(IN) :: lgs_b_value
    REAL(dp), DIMENSION(nmax), INTENT(IN) :: lgs_b_valued
    INTEGER(i4b), INTENT(OUT) :: ierr
    REAL(dp), DIMENSION(nmax), INTENT(INOUT) :: lgs_x_value
    REAL(dp), DIMENSION(nmax), INTENT(INOUT) :: lgs_x_valued
    INTEGER(i4b) :: iter
    INTEGER(i4b) :: iter_max
    INTEGER(i4b) :: nr, k
    REAL(dp), DIMENSION(nmax) :: lgs_x_value_prev
    REAL(dp) :: temp1, temp2
    LOGICAL :: isnanflag1, isnanflag2, isnanflag3
    REAL(dp) :: b_nr
    REAL(dp) :: b_nrd
    LOGICAL :: flag_convergence
    INTRINSIC ABS
    REAL(dp) :: abs0
    REAL(dp) :: temp
    iter_max = 1000
iter_loop:DO iter=1,iter_max
      lgs_x_value_prev = lgs_x_value
      DO nr=1,nmax
        b_nr = 0.0_dp
        b_nrd = 0.0_8
        DO k=lgs_a_ptr(nr),lgs_a_ptr(nr+1)-1
          b_nrd = b_nrd + lgs_x_value(lgs_a_index(k))*lgs_a_valued(k) + &
&           lgs_a_value(k)*lgs_x_valued(lgs_a_index(k))
          b_nr = b_nr + lgs_a_value(k)*lgs_x_value(lgs_a_index(k))
        END DO
        temp = (b_nr-lgs_b_value(nr))/lgs_a_value(lgs_a_diag_index(nr))
        lgs_x_valued(nr) = lgs_x_valued(nr) - omega*(b_nrd-lgs_b_valued(&
&         nr)-temp*lgs_a_valued(lgs_a_diag_index(nr)))/lgs_a_value(&
&         lgs_a_diag_index(nr))
        lgs_x_value(nr) = lgs_x_value(nr) - omega*temp
      END DO
      flag_convergence = .true.
      DO nr=1,nmax
        IF (lgs_x_value(nr) - lgs_x_value_prev(nr) .GE. 0.) THEN
          abs0 = lgs_x_value(nr) - lgs_x_value_prev(nr)
        ELSE
          abs0 = -(lgs_x_value(nr)-lgs_x_value_prev(nr))
        END IF
        IF (abs0 .GT. eps_sor) GOTO 100
      END DO
      GOTO 110
 100  flag_convergence = .false.
 110  IF (flag_convergence) GOTO 120
    END DO iter_loop
    WRITE(6, '(10x,a,i0)') 'sor_sprs: iter = ', iter
! convergence criterion not fulfilled
    ierr = -1
    GOTO 130
 120 WRITE(6, '(10x,a,i0)') 'sor_sprs: iter = ', iter
! convergence criterion fulfilled
    ierr = 0
    RETURN
 130 CONTINUE
  END SUBROUTINE SOR_SPRS_STUB_D

!-------------------------------------------------------------------------------
!> SOR solver for a system of linear equations lgs_a*lgs_x=lgs_b
!! [matrix storage: compressed sparse row CSR,
!! represented by arrays lgs_a_value(values), lgs_a_index (indices)
!! and lgs_a_ptr (pointers)].
!<------------------------------------------------------------------------------
  SUBROUTINE SOR_SPRS_STUB(lgs_a_value, lgs_a_index, lgs_a_diag_index, &
&   lgs_a_ptr, lgs_b_value, nnz, nmax, n_sprs, omega, eps_sor, &
&   lgs_x_value, ierr)
    IMPLICIT NONE
    INTEGER(i4b), INTENT(IN) :: n_sprs
    INTEGER(i4b), INTENT(IN) :: nnz, nmax
    REAL(dp), INTENT(IN) :: omega, eps_sor
    INTEGER(i4b), DIMENSION(nmax+1), INTENT(IN) :: lgs_a_ptr
    INTEGER(i4b), DIMENSION(nnz), INTENT(IN) :: lgs_a_index
    INTEGER(i4b), DIMENSION(nmax), INTENT(IN) :: lgs_a_diag_index
    REAL(dp), DIMENSION(nnz), INTENT(IN) :: lgs_a_value
    REAL(dp), DIMENSION(nmax), INTENT(IN) :: lgs_b_value
    INTEGER(i4b), INTENT(OUT) :: ierr
    REAL(dp), DIMENSION(nmax), INTENT(INOUT) :: lgs_x_value
    INTEGER(i4b) :: iter
    INTEGER(i4b) :: iter_max
    INTEGER(i4b) :: nr, k
    REAL(dp), DIMENSION(nmax) :: lgs_x_value_prev
    REAL(dp) :: temp1, temp2
    LOGICAL :: isnanflag1, isnanflag2, isnanflag3
    REAL(dp) :: b_nr
    LOGICAL :: flag_convergence
    INTRINSIC ABS
    REAL(dp) :: abs0
    iter_max = 1000
iter_loop:DO iter=1,iter_max
      lgs_x_value_prev = lgs_x_value
      DO nr=1,nmax
        b_nr = 0.0_dp
        DO k=lgs_a_ptr(nr),lgs_a_ptr(nr+1)-1
          b_nr = b_nr + lgs_a_value(k)*lgs_x_value(lgs_a_index(k))
        END DO
        lgs_x_value(nr) = lgs_x_value(nr) - omega*(b_nr-lgs_b_value(nr))&
&         /lgs_a_value(lgs_a_diag_index(nr))
      END DO
      flag_convergence = .true.
      DO nr=1,nmax
        IF (lgs_x_value(nr) - lgs_x_value_prev(nr) .GE. 0.) THEN
          abs0 = lgs_x_value(nr) - lgs_x_value_prev(nr)
        ELSE
          abs0 = -(lgs_x_value(nr)-lgs_x_value_prev(nr))
        END IF
        IF (abs0 .GT. eps_sor) THEN
          flag_convergence = .false.
          GOTO 100
        END IF
      END DO
 100  IF (flag_convergence) THEN
        WRITE(6, '(10x,a,i0)') 'sor_sprs: iter = ', iter
! convergence criterion fulfilled
        ierr = 0
        RETURN
      END IF
    END DO iter_loop
    WRITE(6, '(10x,a,i0)') 'sor_sprs: iter = ', iter
! convergence criterion not fulfilled
    ierr = -1
  END SUBROUTINE SOR_SPRS_STUB


!  Differentiation of tri_sle_stub in forward (tangent) mode:
!   variations   of useful results: x b
!   with respect to varying inputs: x a0 a1 a2 b
!-------------------------------------------------------------------------------
!> SOR solver for a system of linear equations lgs_a*lgs_x=lgs_b
!! [matrix storage: compressed sparse row CSR,
!! represented by arrays lgs_a_value(values), lgs_a_index (indices)
!! and lgs_a_ptr (pointers)].
!<------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> Solution of a system of linear equations Ax=b with tridiagonal matrix A.
!! @param[in]  a0       a0(j) is element A_(j,j-1) of Matrix A
!! @param[in]  a1       a1(j) is element A_(j,j)   of Matrix A
!! @param[in]  a2       a2(j) is element A_(j,j+1) of Matrix A
!! @param[in]  b        inhomogeneity vector
!! @param[in]  nrows    size of matrix A (indices run from 0 (!!!) to nrows)
!! @param[out] x        Solution vector.
!<------------------------------------------------------------------------------
  SUBROUTINE TRI_SLE_STUB_D(a0, a0d, a1, a1d, a2, a2d, x, xd, b, bd, &
&   nrows)
    IMPLICIT NONE
    INTEGER(i4b), INTENT(IN) :: nrows
    REAL(dp), DIMENSION(0:nrows), INTENT(IN) :: a0, a2
    REAL(dp), DIMENSION(0:nrows), INTENT(IN) :: a0d, a2d
    REAL(dp), DIMENSION(0:nrows), INTENT(INOUT) :: a1, b
    REAL(dp), DIMENSION(0:nrows), INTENT(INOUT) :: a1d, bd
    REAL(dp), DIMENSION(0:nrows), INTENT(OUT) :: x
    REAL(dp), DIMENSION(0:nrows), INTENT(OUT) :: xd
    REAL(dp), DIMENSION(0:nrows) :: help_x
    REAL(dp), DIMENSION(0:nrows) :: help_xd
    INTEGER(i4b) :: n
    REAL(dp) :: temp
    REAL(dp) :: temp0
!--------  Generate an upper triangular matrix
!                      ('obere Dreiecksmatrix') --------
!x(1) = a0(0) + a1(0) + a2(0) + b(0) 
!x(0) = x(1)
!b(0) = x(1)
!a1(0) = x(1)
    DO n=1,nrows
      temp = a0(n)*a2(n-1)/a1(n-1)
      a1d(n) = a1d(n) - (a2(n-1)*a0d(n)+a0(n)*a2d(n-1)-temp*a1d(n-1))/a1&
&       (n-1)
      a1(n) = a1(n) - temp
    END DO
    DO n=1,nrows
      temp = a0(n)*b(n-1)/a1(n-1)
      bd(n) = bd(n) - (b(n-1)*a0d(n)+a0(n)*bd(n-1)-temp*a1d(n-1))/a1(n-1&
&       )
      b(n) = b(n) - temp
    END DO
!         a0(n)  = 0.0_dp , not needed in the following, therefore
!                           not set
!-------- Iterative solution of the new system --------
!      x(nrows) = b(nrows)/a1(nrows)
!      do n=nrows-1, 0, -1
!         x(n) = (b(n)-a2(n)*x(n+1))/a1(n)
!      end do
    help_xd = 0.0_8
    temp = b(nrows)/a1(nrows)
    help_xd(0) = (bd(nrows)-temp*a1d(nrows))/a1(nrows)
    help_x(0) = temp
    DO n=1,nrows
      temp = b(nrows-n)/a1(nrows-n)
      temp0 = a2(nrows-n)*help_x(n-1)/a1(nrows-n)
      help_xd(n) = (bd(nrows-n)-temp*a1d(nrows-n))/a1(nrows-n) - (help_x&
&       (n-1)*a2d(nrows-n)+a2(nrows-n)*help_xd(n-1)-temp0*a1d(nrows-n))/&
&       a1(nrows-n)
      help_x(n) = temp - temp0
    END DO
    DO n=0,nrows
      xd(n) = help_xd(nrows-n)
      x(n) = help_x(nrows-n)
    END DO
  END SUBROUTINE TRI_SLE_STUB_D

!-------------------------------------------------------------------------------
!> SOR solver for a system of linear equations lgs_a*lgs_x=lgs_b
!! [matrix storage: compressed sparse row CSR,
!! represented by arrays lgs_a_value(values), lgs_a_index (indices)
!! and lgs_a_ptr (pointers)].
!<------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> Solution of a system of linear equations Ax=b with tridiagonal matrix A.
!! @param[in]  a0       a0(j) is element A_(j,j-1) of Matrix A
!! @param[in]  a1       a1(j) is element A_(j,j)   of Matrix A
!! @param[in]  a2       a2(j) is element A_(j,j+1) of Matrix A
!! @param[in]  b        inhomogeneity vector
!! @param[in]  nrows    size of matrix A (indices run from 0 (!!!) to nrows)
!! @param[out] x        Solution vector.
!<------------------------------------------------------------------------------
  SUBROUTINE TRI_SLE_STUB(a0, a1, a2, x, b, nrows)
    IMPLICIT NONE
    INTEGER(i4b), INTENT(IN) :: nrows
    REAL(dp), DIMENSION(0:nrows), INTENT(IN) :: a0, a2
    REAL(dp), DIMENSION(0:nrows), INTENT(INOUT) :: a1, b
    REAL(dp), DIMENSION(0:nrows), INTENT(OUT) :: x
    REAL(dp), DIMENSION(0:nrows) :: help_x
    INTEGER(i4b) :: n
!--------  Generate an upper triangular matrix
!                      ('obere Dreiecksmatrix') --------
!x(1) = a0(0) + a1(0) + a2(0) + b(0) 
!x(0) = x(1)
!b(0) = x(1)
!a1(0) = x(1)
    DO n=1,nrows
      a1(n) = a1(n) - a0(n)/a1(n-1)*a2(n-1)
    END DO
    DO n=1,nrows
      b(n) = b(n) - a0(n)/a1(n-1)*b(n-1)
    END DO
!         a0(n)  = 0.0_dp , not needed in the following, therefore
!                           not set
!-------- Iterative solution of the new system --------
!      x(nrows) = b(nrows)/a1(nrows)
!      do n=nrows-1, 0, -1
!         x(n) = (b(n)-a2(n)*x(n+1))/a1(n)
!      end do
    help_x(0) = b(nrows)/a1(nrows)
    DO n=1,nrows
      help_x(n) = b(nrows-n)/a1(nrows-n) - a2(nrows-n)/a1(nrows-n)*&
&       help_x(n-1)
    END DO
    DO n=0,nrows
      x(n) = help_x(nrows-n)
    END DO
  END SUBROUTINE TRI_SLE_STUB

!-------------------------------------------------------------------------------
!> Bilinear interpolation.
!<------------------------------------------------------------------------------
  SUBROUTINE BILININT_STUB(x1, x2, y1, y2, z11, z12, z21, z22, x, y, &
&   retval)
    IMPLICIT NONE
    REAL(dp), INTENT(IN) :: x1, x2, y1, y2, z11, z12, z21, z22, x, y
    REAL(dp) :: t, u
    REAL(dp), INTENT(OUT) :: retval
    REAL(dp), PARAMETER :: i=1.0_dp
    t = (x-x1)/(x2-x1)
    u = (y-y1)/(y2-y1)
    retval = (i-t)*(i-u)*z11 + (i-t)*u*z12 + t*(i-u)*z21 + t*u*z22
  END SUBROUTINE BILININT_STUB

!  Differentiation of my_erfc_stub in forward (tangent) mode:
!   variations   of useful results: retval
!   with respect to varying inputs: x
!-------------------------------------------------------------------------------
!> Computation of the complementary error function erfc(x) = 1-erf(x)
!! with a fractional error everywhere less than 1.2 x 10^(-7)
!! (formula by Press et al., 'Numerical Recipes in Fortran 77').
!<------------------------------------------------------------------------------
  SUBROUTINE MY_ERFC_STUB_D(x, xd, retval, retvald)
    IMPLICIT NONE
    REAL(dp), INTENT(IN) :: x
    REAL(dp), INTENT(IN) :: xd
    REAL(dp), INTENT(OUT) :: retval
    REAL(dp), INTENT(OUT) :: retvald
    REAL(dp) :: t, z
    REAL(dp) :: td, zd
    INTRINSIC ABS
    INTRINSIC EXP
    REAL(dp) :: arg1
    REAL(dp) :: arg1d
    REAL(dp) :: temp
    REAL(dp) :: temp0
    REAL(dp) :: temp1
    REAL(dp) :: temp2
    IF (x .GE. 0.) THEN
      zd = xd
      z = x
    ELSE
      zd = -xd
      z = -x
    END IF
    temp = 1.0/(0.5_dp*z+1.0_dp)
    td = -(temp*0.5_dp*zd/(0.5_dp*z+1.0_dp))
    t = temp
    temp = t*(0.17087277_dp*t-0.82215223_dp) + 1.48851587_dp
    temp0 = t*temp - 1.13520398_dp
    temp1 = t*(t*temp0+0.27886807_dp) - 0.18628806_dp
    temp2 = t*(t*temp1+0.09678418_dp) + 0.37409196_dp
    arg1d = (t*temp2+t*(temp2+t*(t*temp1+t*(temp1+t*(t*temp0+t*(temp0+t*&
&     (temp+t*(0.17087277_dp*t+t*0.17087277_dp-0.82215223_dp)))+&
&     0.27886807_dp))+0.09678418_dp))+1.00002368_dp)*td - 2*z*zd
    arg1 = t*(t*temp2+1.00002368_dp) - z*z - 1.26551223_dp
    temp2 = EXP(arg1)
    retvald = temp2*td + t*EXP(arg1)*arg1d
    retval = t*temp2
    IF (x .LT. 0.0_dp) THEN
      retvald = -retvald
      retval = 2.0_dp - retval
    END IF
  END SUBROUTINE MY_ERFC_STUB_D

!-------------------------------------------------------------------------------
!> Computation of the complementary error function erfc(x) = 1-erf(x)
!! with a fractional error everywhere less than 1.2 x 10^(-7)
!! (formula by Press et al., 'Numerical Recipes in Fortran 77').
!<------------------------------------------------------------------------------
  SUBROUTINE MY_ERFC_STUB(x, retval)
    IMPLICIT NONE
    REAL(dp), INTENT(IN) :: x
    REAL(dp), INTENT(OUT) :: retval
    REAL(dp) :: t, z
    INTRINSIC ABS
    INTRINSIC EXP
    REAL(dp) :: arg1
    IF (x .GE. 0.) THEN
      z = x
    ELSE
      z = -x
    END IF
    t = 1.0_dp/(1.0_dp+0.5_dp*z)
    arg1 = -(z*z) - 1.26551223_dp + t*(1.00002368_dp+t*(0.37409196_dp+t*&
&     (0.09678418_dp+t*(-0.18628806_dp+t*(0.27886807_dp+t*(-&
&     1.13520398_dp+t*(1.48851587_dp+t*(-0.82215223_dp+t*0.17087277_dp))&
&     ))))))
    retval = t*EXP(arg1)
    IF (x .LT. 0.0_dp) retval = 2.0_dp - retval
  END SUBROUTINE MY_ERFC_STUB

!-------------------------------------------------------------------------------
  SUBROUTINE MY_ERFC(x, retval)
    IMPLICIT NONE
    REAL(dp), INTENT(IN) :: x
    REAL(dp), INTENT(OUT) :: retval
    REAL(dp) :: t, z
    INTRINSIC ABS
    INTRINSIC EXP
    REAL(dp) :: arg1
    IF (x .GE. 0.) THEN
      z = x
    ELSE
      z = -x
    END IF
    t = 1.0_dp/(1.0_dp+0.5_dp*z)
    arg1 = -(z*z) - 1.26551223_dp + t*(1.00002368_dp+t*(0.37409196_dp+t*&
&     (0.09678418_dp+t*(-0.18628806_dp+t*(0.27886807_dp+t*(-&
&     1.13520398_dp+t*(1.48851587_dp+t*(-0.82215223_dp+t*0.17087277_dp))&
&     ))))))
    retval = t*EXP(arg1)
    IF (x .LT. 0.0_dp) retval = 2.0_dp - retval
  END SUBROUTINE MY_ERFC

#if  defined(BUILD_LIS) && (CALCTHK==3 || CALCTHK==6 || MARGIN==3 || DYNAMICS==2)
!#if  (CALCTHK==3 || CALCTHK==6 || MARGIN==3 || DYNAMICS==2)
!-------------------------------------------------------------------------------
!> OpenAD needs a template to help differentiate through the LIS solver when  
!! it is used. This is substituted in for adjoint modes in Antarctica with 
!! ice shelves.
!<------------------------------------------------------------------------------
#include "lisf.h"
  SUBROUTINE SICO_LIS_SOLVER_STUB(nmax, nnz, lgs_a_ptr, lgs_a_index, &
&   lgs_a_value, lgs_b_value, lgs_x_value)
implicit none

integer(i4b)                                 :: ierr
integer(i4b)                                 :: iter
integer(i4b)                                 :: nc, nr
integer(i4b),                     intent(in) :: nmax
integer(i4b),                     intent(in) :: nnz
integer(i4b), dimension(nmax+1),  intent(in) :: lgs_a_ptr
integer(i4b), dimension(nnz),  intent(in)    :: lgs_a_index

LIS_MATRIX                                   :: lgs_a
LIS_VECTOR                                   :: lgs_b
LIS_VECTOR                                   :: lgs_x
LIS_SOLVER                                   :: solver

real(dp),     dimension(nnz),  intent(in)    :: lgs_a_value
real(dp),     dimension(nmax),    intent(in) :: lgs_b_value
real(dp),     dimension(nmax), intent(inout) :: lgs_x_value

character(len=256)                           :: ch_solver_set_option

!  ------ Settings for Lis
call lis_init_f(ierr)
call lis_matrix_create(LIS_COMM_WORLD, lgs_a, ierr)
call lis_vector_create(LIS_COMM_WORLD, lgs_b, ierr)
call lis_vector_create(LIS_COMM_WORLD, lgs_x, ierr)

call lis_matrix_set_size(lgs_a, 0, nmax, ierr)
call lis_vector_set_size(lgs_b, 0, nmax, ierr)
call lis_vector_set_size(lgs_x, 0, nmax, ierr)

do nr=1, nmax

   do nc=lgs_a_ptr(nr), lgs_a_ptr(nr+1)-1
      call lis_matrix_set_value(LIS_INS_VALUE, nr, lgs_a_index(nc), &
                                               lgs_a_value(nc), lgs_a, ierr)
   end do

   call lis_vector_set_value(LIS_INS_VALUE, nr, lgs_b_value(nr), lgs_b, ierr)
   call lis_vector_set_value(LIS_INS_VALUE, nr, lgs_x_value(nr), lgs_x, ierr)

end do

call lis_matrix_set_type(lgs_a, LIS_MATRIX_CSR, ierr)
call lis_matrix_assemble(lgs_a, ierr)

!  ------ Solution with Lis

call lis_solver_create(solver, ierr)

#if (defined(LIS_OPTS))
    ch_solver_set_option = trim(LIS_OPTS)
#else
    ch_solver_set_option = '-i bicgsafe -p jacobi '// &
                           '-maxiter 2000 -tol 1.0e-18 -initx_zeros false'
#endif

call lis_solver_set_option(trim(ch_solver_set_option), solver, ierr)
call CHKERR(ierr)

call lis_solve(lgs_a, lgs_b, lgs_x, solver, ierr)
call CHKERR(ierr)

call lis_solver_get_iter(solver, iter, ierr)
write(6,'(10x,a,i0)') 'calc_thk_sia_impl: iter = ', iter

lgs_x_value = 0.0_dp
call lis_vector_gather(lgs_x, lgs_x_value, ierr)
call lis_matrix_destroy(lgs_a, ierr)
call lis_vector_destroy(lgs_b, ierr)
call lis_vector_destroy(lgs_x, ierr)
call lis_solver_destroy(solver, ierr)
call lis_finalize_f(ierr)
  END SUBROUTINE SICO_LIS_SOLVER_STUB

subroutine sico_lis_solver_stub_d(nmax, nnz, &
                           lgs_a_ptr, lgs_a_index, &
                           lgs_a_value, lgs_a_valued, lgs_b_value,& 
                           lgs_b_valued, lgs_x_value, lgs_x_valued)

implicit none

integer(i4b)                                 :: ierr
integer(i4b)                                 :: nc, nr
integer(i4b),                     intent(in) :: nmax
integer(i4b),                     intent(in) :: nnz
integer(i4b), dimension(nmax+1),  intent(in) :: lgs_a_ptr
integer(i4b), dimension(nnz),  intent(in) :: lgs_a_index

real(dp),     dimension(nnz),  intent(in) :: lgs_a_value
real(dp),     dimension(nmax),    intent(in) :: lgs_b_value
real(dp),     dimension(nmax), intent(inout) :: lgs_x_value

real(dp),     dimension(nnz),  intent(inout) :: lgs_a_valued
real(dp),     dimension(nmax), intent(inout) :: lgs_b_valued
real(dp),     dimension(nmax), intent(inout) :: lgs_x_valued
real(dp),     dimension(nmax) :: rhs_value

LIS_MATRIX                                   :: lgs_ad
LIS_VECTOR                                   :: lgs_bd
LIS_VECTOR                                   :: lgs_x
LIS_VECTOR                                   :: rhs

call lis_init_f(ierr)
call lis_matrix_create(LIS_COMM_WORLD, lgs_ad, ierr)
call lis_vector_create(LIS_COMM_WORLD, lgs_bd, ierr)
call lis_vector_create(LIS_COMM_WORLD, lgs_x, ierr)
call lis_vector_create(LIS_COMM_WORLD, rhs, ierr)

call lis_matrix_set_size(lgs_ad, 0, nmax, ierr)
call lis_vector_set_size(lgs_bd, 0, nmax, ierr)
call lis_vector_set_size(lgs_x, 0, nmax, ierr)
call lis_vector_set_size(rhs, 0, nmax, ierr)

call sico_lis_solver(nmax, nnz, &
                    & lgs_a_ptr, lgs_a_index, &
                    & lgs_a_value, lgs_b_value, lgs_x_value)

do nr=1, nmax

   do nc=lgs_a_ptr(nr), lgs_a_ptr(nr+1)-1
      call lis_matrix_set_value(LIS_INS_VALUE, nr, lgs_a_index(nc), &
                               & lgs_a_valued(nc), lgs_ad, ierr)
   end do

   call lis_vector_set_value(LIS_INS_VALUE, nr, lgs_b_valued(nr), lgs_bd, ierr)
   call lis_vector_set_value(LIS_INS_VALUE, nr, lgs_x_value(nr), lgs_x, ierr)

end do

call lis_matrix_set_type(lgs_ad, LIS_MATRIX_CSR, ierr)
call lis_matrix_assemble(lgs_ad, ierr)
call lis_matvec(lgs_ad, lgs_x, rhs, ierr) 
call lis_vector_xpay(-1, lgs_bd, rhs, ierr)

rhs_value = 0.0_dp
call lis_vector_gather(rhs, rhs_value, ierr)

call sico_lis_solver(nmax, nnz, &
                    & lgs_a_ptr, lgs_a_index, &
                    & lgs_a_value, rhs_value, lgs_x_valued)

end subroutine sico_lis_solver_stub_d

#endif
END MODULE SICO_MATHS_M_DIFF
!

